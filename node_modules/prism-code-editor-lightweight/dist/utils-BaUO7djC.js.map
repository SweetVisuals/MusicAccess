{"version":3,"file":"utils-BaUO7djC.js","sources":["../src/extensions/autocomplete/utils.ts"],"sourcesContent":["import { PrismEditor } from \"../../index.js\"\nimport { Token } from \"../../prism/core.js\"\nimport { TokenStream } from \"../../prism/types.js\"\nimport { matchTemplate } from \"../search/search.js\"\nimport { Completion, CompletionContext, CompletionSource } from \"./types.js\"\n\nconst optionsFromKeys = (obj: object, icon?: string): Completion[] =>\n\tObject.keys(obj).map(tag => ({ label: tag, icon }))\n\nconst updateNode = (node: Text, text: string) => {\n\tif (node.data != text) node.data = text\n}\n\nconst updateMatched = (container: HTMLElement, matched: number[], text: string) => {\n\tlet nodes = container.childNodes\n\tlet nodeCount = nodes.length - 1\n\tlet pos = 0\n\tlet i = 0\n\tlet l = matched.length\n\n\tfor (; i < l; ) {\n\t\tif (i >= nodeCount) {\n\t\t\tnodes[i].before(\"\", matchTemplate())\n\t\t}\n\t\tupdateNode(nodes[i] as Text, text.slice(pos, (pos = matched[i++])))\n\t\tupdateNode(nodes[i].firstChild as Text, text.slice(pos, (pos = matched[i++])))\n\t}\n\tfor (; nodeCount > i; ) {\n\t\tnodes[--nodeCount].remove()\n\t}\n\tupdateNode(nodes[l] as Text, text.slice(pos))\n}\n\n/**\n * Completion source that returns a list of snippets if `path` property of the context\n * is present and only contains a single string.\n * @param snippets Snippets to complete.\n */\nconst completeSnippets = (snippets: Completion[]): CompletionSource<{ path: string[] | null }> => {\n\treturn ({ path, explicit, pos }) => {\n\t\tif (path?.length == 1 && (path[0] || explicit)) {\n\t\t\treturn {\n\t\t\t\tfrom: pos - path[0].length,\n\t\t\t\toptions: snippets,\n\t\t\t}\n\t\t}\n\t}\n}\n\n/**\n * Utility that searches the editor's {@link TokenStream} for strings.\n * @param context Current completion context.\n * @param editor Editor to search in.\n * @param filter Function used to filter tokens you want to search in. Is called with the\n * type of the token and its starting position. If the filter returns true, the token\n * will be searched.\n * @param pattern Pattern used to search for words.\n * @param init Words to initialize the result with.\n * @param tokensOnly If `true` only the text of tokens whoose `content` is a string will\n * be searched. If not any string inside the {@link TokenStream} can be searched.\n * @returns An array with found identifers/words.\n */\nconst findWords = (\n\tcontext: CompletionContext,\n\teditor: PrismEditor,\n\tfilter: (type: string, start: number) => boolean,\n\tpattern: RegExp,\n\tinit?: Iterable<string>,\n\ttokensOnly?: boolean,\n) => {\n\tconst cursorPos = context.pos\n\tconst language = context.language\n\tconst result = new Set(init)\n\tconst search = (tokens: TokenStream, pos: number, isCorrectLang: boolean) => {\n\t\tlet i = 0\n\t\tlet token: string | Token\n\t\tif (isCorrectLang) {\n\t\t\tfor (; (token = tokens[i++]); ) {\n\t\t\t\tif (typeof token == \"string\") {\n\t\t\t\t\tif (!tokensOnly) match(token, pos)\n\t\t\t\t} else {\n\t\t\t\t\tconst type = token.type\n\t\t\t\t\tconst content = token.content\n\t\t\t\t\tif ((token.alias || type).slice(0, 9) != \"language-\" && filter(type, pos)) {\n\t\t\t\t\t\tif (Array.isArray(content)) {\n\t\t\t\t\t\t\tsearch(content, pos, true)\n\t\t\t\t\t\t} else match(content, pos)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tpos += token.length\n\t\t\t}\n\t\t} else {\n\t\t\tfor (; (token = tokens[i++]); ) {\n\t\t\t\tif (typeof token != \"string\") {\n\t\t\t\t\tconst type = token.type\n\t\t\t\t\tconst content = token.content\n\t\t\t\t\tif (Array.isArray(content)) {\n\t\t\t\t\t\tconst aliasType = token.alias || type\n\t\t\t\t\t\tsearch(\n\t\t\t\t\t\t\tcontent,\n\t\t\t\t\t\t\tpos,\n\t\t\t\t\t\t\taliasType.slice(0, 9) == \"language-\" ? aliasType.slice(9) == language : false,\n\t\t\t\t\t\t)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tpos += token.length\n\t\t\t}\n\t\t}\n\t}\n\tconst match = (token: string, pos: number) => {\n\t\tlet match: RegExpExecArray | null\n\t\twhile ((match = pattern.exec(token))) {\n\t\t\tlet start = pos + match.index\n\t\t\tlet str = match[0]\n\t\t\tif (start > cursorPos || start + str.length < cursorPos) result.add(str)\n\t\t}\n\t}\n\n\tsearch(editor.tokens, 0, language == editor.options.language)\n\n\treturn [...result]\n}\n\nexport { optionsFromKeys, updateMatched, updateNode, findWords, completeSnippets }\n"],"names":["match"],"mappings":"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"}