{"version":3,"file":"index-XEj74r-1.js","sources":["../src/prism/core.js"],"sourcesContent":["// Slimmed down Prism core with most high level functions removed\n\nvar plainTextGrammar = {};\nvar rest = Symbol();\nvar tokenize = Symbol();\n\nvar resolve = id => typeof id == 'string' ? languages[id] : id;\n\nvar languages = {\n\tplain: plainTextGrammar,\n\tplaintext: plainTextGrammar,\n\ttext: plainTextGrammar,\n\ttxt: plainTextGrammar,\n};\n\n/**\n * @param {string} text\n * @param {any} grammar\n */\nvar tokenizeText = (text, grammar) => (grammar[tokenize] || withoutTokenizer)(text, grammar);\n\n/**\n * @param {string} text\n * @param {any} grammar\n */\nvar withoutTokenizer = (text, grammar) => {\n\tvar startNode = [text];\n\tvar restGrammar;\n\tvar array = [], i = 0;\n\twhile (restGrammar = resolve(grammar[rest])) {\n\t\tdelete grammar[rest];\n\t\tObject.assign(grammar, restGrammar);\n\t}\n\n\tmatchGrammar(text, grammar, startNode, 0);\n\n\twhile (array[i++] = startNode[0], startNode = startNode[1]);\n\treturn array;\n}\n\nvar closingTag = '</span>';\nvar openingTags = '';\nvar closingTags = '';\n\nvar highlightTokens = tokens => {\n\tvar str = '', l = tokens.length, i = 0;\n\twhile (i < l) str += stringify(tokens[i++]);\n\treturn str;\n}\n\n/** @param {string | Token | (string | Token)[]} token */\nvar stringify = token => {\n\tif (token instanceof Token) {\n\t\tvar { type, alias, content } = token;\n\t\tvar prevOpening = openingTags;\n\t\tvar prevClosing = closingTags;\n\t\tvar opening = `<span class=\"token ${\n\t\t\ttype + (alias ? ' ' + alias : '') +\n\t\t\t(type == 'keyword' && typeof content == 'string' ? ' keyword-' + content : '')\n\t\t}\">`;\n\n\t\tclosingTags += closingTag;\n\t\topeningTags += opening;\n\t\tvar contentStr = stringify(content);\n\t\topeningTags = prevOpening;\n\t\tclosingTags = prevClosing;\n\t\treturn opening + contentStr + closingTag;\n\t}\n\n\tif (typeof token != 'string') return highlightTokens(token);\n\n\ttoken = token.replace(/&/g, '&amp;').replace(/</g, '&lt;');\n\tif (closingTags && token.includes('\\n')) {\n\t\treturn token.replace(/\\n/g, closingTags + '\\n' + openingTags);\n\t}\n\treturn token;\n}\n\nvar highlightText = (text, ref) => highlightTokens(tokenizeText(text, resolve(ref)));\n\n/**\n * @param {string} text\n * @param {any} grammar\n * @param {LinkedListNode} startNode\n * @param {number} startPos\n * @param {[string, number, number]} rematch\n * @returns {number | undefined}\n * @private\n *\n * @typedef {[string | Token, LinkedListNode?]} LinkedListNode\n */\nvar matchGrammar = (text, grammar, startNode, startPos, rematch) => {\n\tfor (var token in grammar) {\n\t\tif (grammar[token]) for (var j = 0, p = grammar[token], patterns = Array.isArray(p) ? p : [p]; j < patterns.length; ++j) {\n\t\t\tif (rematch && rematch[0] == token && rematch[1] == j) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar patternObj = patterns[j];\n\t\t\t/** @type {RegExp} */\n\t\t\tvar pattern = patternObj.pattern || patternObj;\n\t\t\tvar inside = resolve(patternObj.inside);\n\t\t\tvar lookbehind = patternObj.lookbehind;\n\t\t\tvar greedy = patternObj.greedy && pattern.global;\n\t\t\tvar alias = patternObj.alias;\n\n\t\t\tfor ( // iterate the token list and keep track of the current token/string position\n\t\t\t\tvar currentNode = startNode, pos = startPos;\n\t\t\t\tcurrentNode && (!rematch || pos < rematch[2]);\n\t\t\t\tpos += currentNode[0].length, currentNode = currentNode[1]\n\t\t\t) {\n\t\t\t\tvar str = currentNode[0];\n\t\t\t\tvar removeCount = 0;\n\t\t\t\tvar match, lookbehindLength;\n\n\t\t\t\tif (str instanceof Token) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tpattern.lastIndex = greedy ? pos : 0;\n\t\t\t\tmatch = pattern.exec(greedy ? text : str);\n\n\t\t\t\tif (match && lookbehind && match[1]) {\n\t\t\t\t\t// change the match to remove the text matched by the Prism lookbehind group\n\t\t\t\t\tlookbehindLength = match[1].length;\n\t\t\t\t\tmatch.index += lookbehindLength;\n\t\t\t\t\tmatch[0] = match[0].slice(lookbehindLength);\n\t\t\t\t}\n\n\t\t\t\tif (greedy) {\n\t\t\t\t\tif (!match) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (match[0]) {\n\t\t\t\t\t\t// find the node that contains the match\n\t\t\t\t\t\tfor (\n\t\t\t\t\t\t\tvar from = match.index, to = from + match[0].length, l;\n\t\t\t\t\t\t\tfrom >= pos + (l = currentNode[0].length);\n\t\t\t\t\t\t\tcurrentNode = currentNode[1], pos += l\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\t// the current node is a Token, then the match starts inside another Token, which is invalid\n\t\t\t\t\t\tif (currentNode[0] instanceof Token) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// find the last node which is affected by this match\n\t\t\t\t\t\tfor (\n\t\t\t\t\t\t\tvar k = currentNode, p = pos;\n\t\t\t\t\t\t\t(p += k[0].length) < to;\n\t\t\t\t\t\t\tk = k[1], removeCount++\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\t// replace with the new match\n\t\t\t\t\t\tstr = text.slice(pos, p);\n\t\t\t\t\t\tmatch.index -= pos;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!(match && match[0])) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// eslint-disable-next-line no-redeclare\n\t\t\t\tvar from = match.index;\n\t\t\t\tvar matchStr = match[0];\n\t\t\t\tvar after = str.slice(from + matchStr.length);\n\t\t\t\tvar reach = pos + str.length;\n\t\t\t\tvar newToken = new Token(token, inside ? tokenizeText(matchStr, inside) : matchStr, matchStr, alias);\n\t\t\t\tvar next = currentNode, i = 0;\n\t\t\t\tvar nestedRematch;\n\n\t\t\t\twhile (next = next[1], i++ < removeCount);\n\n\t\t\t\tif (after) {\n\t\t\t\t\tif (!next || next[0] instanceof Token) next = [after, next];\n\t\t\t\t\telse next[0] = after + next[0];\n\t\t\t\t};\n\n\t\t\t\tpos += from;\n\t\t\t\tcurrentNode[0] = from ? str.slice(0, from) : newToken;\n\n\t\t\t\tif (from) currentNode = currentNode[1] = [newToken, next];\n\t\t\t\telse currentNode[1] = next;\n\n\t\t\t\tif (removeCount) {\n\t\t\t\t\t// at least one Token object was removed, so we have to do some rematching\n\t\t\t\t\t// this can only happen if the current pattern is greedy\n\n\t\t\t\t\tmatchGrammar(text, grammar, currentNode, pos, nestedRematch = [token, j, reach]);\n\t\t\t\t\treach = nestedRematch[2];\n\t\t\t\t}\n\n\t\t\t\tif (rematch && reach > rematch[2]) rematch[2] = reach;\n\t\t\t}\n\t\t}\n\t}\n}\n\n/**\n * Creates a new token.\n *\n * @param {string} type\n * @param {string | any[]} content\n * @param {string} matchedStr\n * @param {string} alias\n * @class\n */\nfunction Token(type, content, matchedStr, alias) {\n\tthis.type = type;\n\tthis.content = content;\n\tthis.alias = alias;\n\tthis.length = matchedStr.length;\n}\n\nexport {\n\trest,\n\ttokenize,\n\tToken,\n\tlanguages,\n\ttokenizeText,\n\twithoutTokenizer,\n\tresolve,\n\thighlightTokens,\n\thighlightText\n}\n"],"names":[],"mappings":"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"}