{"version":3,"file":"sml.js","sources":["../../../src/prism/languages/sml.js"],"sourcesContent":["import { languages } from '../core.js';\nimport { clikePunctuation } from '../utils/patterns.js';\nimport { re, replace } from '../utils/shared.js';\n\nvar keywords = /\\b(?:abstype|[ae]nd|andalso|as|case|datatype|do|else|eqtype|exception|fu?n|functor|handle|if|in|include|infixr?|let|local|nonfix|of|op|open|orelse|raise|rec|sharing|sig|signature|struct|structure|then|type|val|where|while|with|withtype)\\b/i;\n\nvar longId = `(?!${keywords.source})[a-z\\\\d_][\\\\w'.]*`;\n\nvar class0 = {\n\t// This is only an approximation since the real grammar is context-free\n\t//\n\t// Why the main loop so complex?\n\t// The main loop is approximately the same as /(?:\\s*(?:[*,]|->)\\s*<TERMINAL>)*/ which is, obviously, a lot\n\t// simpler. The difference is that if a comma is the last iteration of the loop, then the terminal must be\n\t// followed by a long identifier.\n\tpattern: re(\n\t\t/((?:^|[^:]):\\s*)<0>(?:\\s*(?:(?:\\*|->)\\s*<0>|,\\s*<0>(?:(?=\\s*(?:[*,]|->))|(?!\\s*(?:[*,]|->))\\s+<1>)))*/.source,\n\t\t[replace(/(?:'[\\w']*|<0>|\\((?:[^()]|\\([^)]*\\))*\\)|\\{(?:[^{}]|\\{[^}]*\\})*\\})(?:\\s+<0>)*/.source, [longId]), longId],\n\t\t'gi'\n\t),\n\tlookbehind: true,\n\tgreedy: true\n};\n\nclass0.inside = languages.smlnj = languages.sml = {\n\t// allow one level of nesting\n\t'comment': /\\(\\*(?:[^*(]|\\*(?!\\))|\\((?!\\*)|\\(\\*(?:[^*(]|\\*(?!\\))|\\((?!\\*))*\\*\\))*\\*\\)/,\n\t'string': {\n\t\tpattern: /#?\"(?:\\\\.|[^\\\\\"])*\"/g,\n\t\tgreedy: true\n\t},\n\n\t'class-name': [\n\t\tclass0,\n\t\t{\n\t\t\tpattern: /((?:^|[^\\w'])(?:datatype|exception|functor|signature|structure|type)\\s+)[a-z_][\\w'.]*/i,\n\t\t\tlookbehind: true\n\t\t}\n\t],\n\t'function': {\n\t\tpattern: /((?:^|[^\\w'])fun\\s+)[a-z_][\\w'.]*/i,\n\t\tlookbehind: true\n\t},\n\n\t'keyword': keywords,\n\t'variable': {\n\t\tpattern: /(^|[^\\w'])'[\\w']*/,\n\t\tlookbehind: true,\n\t},\n\n\t'number': /~?\\b(?:\\d+(?:\\.\\d+)?(?:e~?\\d+)?|0x[a-f\\d]+)\\b/i,\n\t'word': {\n\t\tpattern: /\\b0w(?:\\d+|x[a-f\\d]+)\\b/i,\n\t\talias: 'constant'\n\t},\n\n\t'boolean': /\\b(?:false|true)\\b/i,\n\t'operator': /\\.{3}|:[>=:]|=>?|->|[<>]=?|[|^#@~!/*+-]/,\n\t'punctuation': clikePunctuation\n};\n"],"names":[],"mappings":";;;AAIA,IAAI,WAAW;AAEf,IAAI,SAAS,MAAM,SAAS,MAAM;AAElC,IAAI,SAAS;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOZ,SAAS;AAAA,IACR;AAAA,IACA,CAAC,QAAQ,0FAAuF,CAAC,MAAM,CAAC,GAAG,MAAM;AAAA,IACjH;AAAA,EACA;AAAA,EACD,YAAY;AAAA,EACZ,QAAQ;AACT;AAEA,OAAO,SAAS,UAAU,QAAQ,UAAU,MAAM;AAAA;AAAA,EAEjD,WAAW;AAAA,EACX,UAAU;AAAA,IACT,SAAS;AAAA,IACT,QAAQ;AAAA,EACR;AAAA,EAED,cAAc;AAAA,IACb;AAAA,IACA;AAAA,MACC,SAAS;AAAA,MACT,YAAY;AAAA,IACf;AAAA,EACE;AAAA,EACD,YAAY;AAAA,IACX,SAAS;AAAA,IACT,YAAY;AAAA,EACZ;AAAA,EAED,WAAW;AAAA,EACX,YAAY;AAAA,IACX,SAAS;AAAA,IACT,YAAY;AAAA,EACZ;AAAA,EAED,UAAU;AAAA,EACV,QAAQ;AAAA,IACP,SAAS;AAAA,IACT,OAAO;AAAA,EACP;AAAA,EAED,WAAW;AAAA,EACX,YAAY;AAAA,EACZ,eAAe;AAChB;"}