{"version":3,"file":"graphql.js","sources":["../../../src/prism/languages/graphql.js"],"sourcesContent":["import { languages, tokenize, withoutTokenizer } from '../core.js';\nimport { boolean } from '../utils/patterns.js';\n\nlanguages.graphql = {\n\t'comment': /#.*/,\n\t'description': {\n\t\tpattern: /(?:\"\"\"(?:[^\"]|\"(?!\"\"))*\"\"\"|\"(?:\\\\.|[^\\\\\\n\"])*\")(?=\\s*[a-z_])/gi,\n\t\tgreedy: true,\n\t\talias: 'string',\n\t\tinside: {\n\t\t\t'language-markdown': {\n\t\t\t\tpattern: /(\"(?!\")|\"\"\")[\\s\\S]+(?=\\1)/,\n\t\t\t\tlookbehind: true,\n\t\t\t\tinside: 'md'\n\t\t\t}\n\t\t}\n\t},\n\t'string': {\n\t\tpattern: /\"\"\"[\\s\\S]*?\"\"\"|\"(?:\\\\.|[^\\\\\\n\"])*\"/g,\n\t\tgreedy: true\n\t},\n\t'number': /(?:\\B-|\\b)\\d+(?:\\.\\d+)?(?:e[+-]?\\d+)?\\b/i,\n\t'boolean': boolean,\n\t'variable': /\\$[a-z_]\\w*/i,\n\t'directive': {\n\t\tpattern: /@[a-z_]\\w*/i,\n\t\talias: 'function'\n\t},\n\t'attr-name': {\n\t\tpattern: /\\b[a-z_]\\w*(?=\\s*(?:\\((?:[^()\"]|\"(?:\\\\.|[^\\\\\\n\"])*\")*\\))?:)/gi,\n\t\tgreedy: true\n\t},\n\t'atom-input': {\n\t\tpattern: /\\b[A-Z]\\w*Input\\b/,\n\t\talias: 'class-name'\n\t},\n\t'scalar': /\\b(?:Boolean|Float|ID|Int|String)\\b/,\n\t'constant': /\\b[A-Z][A-Z_\\d]*\\b/,\n\t'class-name': {\n\t\tpattern: /(\\b(?:enum|implements|interface|on|scalar|type|union)\\s+|&\\s*|:\\s*|\\[)[A-Z_]\\w*/,\n\t\tlookbehind: true\n\t},\n\t'fragment': {\n\t\tpattern: /(\\bfragment\\s+|\\.{3}\\s*(?!on\\b))(?!\\d)\\w+/,\n\t\tlookbehind: true,\n\t\talias: 'function'\n\t},\n\t'definition-mutation': {\n\t\tpattern: /(\\bmutation\\s+)(?!\\d)\\w+/,\n\t\tlookbehind: true,\n\t\talias: 'function'\n\t},\n\t'definition-query': {\n\t\tpattern: /(\\bquery\\s+)(?!\\d)\\w+/,\n\t\tlookbehind: true,\n\t\talias: 'function'\n\t},\n\t'keyword': /\\b(?:directive|enum|extend|fragment|implements|input|interface|mutation|on|query|repeatable|scalar|schema|subscription|type|union)\\b/,\n\t'operator': /[&|!=]|\\.{3}/,\n\t'property-query': /\\w+(?=\\s*\\()/,\n\t'object': /\\w+(?=\\s*\\{)/,\n\t'punctuation': /[()[\\]{},:!=]/,\n\t'property': /\\w+/,\n\t[tokenize](code, grammar) {\n\t\tvar tokens = withoutTokenizer(code, grammar);\n\n\t\t/**\n\t\t * get the graphql token stream that we want to customize\n\t\t *\n\t\t * @typedef {InstanceType<import(\"../core.js\")[\"Token\"]>} Token\n\t\t * @type {Token[]}\n\t\t */\n\t\tvar validTokens = tokens.filter(({type}) => type && type != 'comment' && type != 'scalar');\n\t\tvar l = validTokens.length;\n\t\tvar currentIndex = 0;\n\n\t\t/**\n\t\t * Returns whether the token relative to the current index has the given type.\n\t\t *\n\t\t * @param {readonly string[]} types\n\t\t * @returns {boolean}\n\t\t */\n\t\tvar isNotTokenType = types => {\n\t\t\tfor (var i = 0; i < types.length; i++) {\n\t\t\t\tif (currentIndex + i == l || validTokens[currentIndex + i].type != types[i]) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * Returns the index of the closing bracket to an opening bracket.\n\t\t *\n\t\t * It is assumed that `token[currentIndex - 1]` is an opening bracket.\n\t\t *\n\t\t * If no closing bracket could be found, `-1` will be returned.\n\t\t *\n\t\t * @param {string} open\n\t\t * @param {string} close\n\t\t * @returns {number | void}\n\t\t */\n\t\tvar findClosingBracket = (open, close) => {\n\t\t\tvar stackHeight = 1;\n\n\t\t\tfor (var i = currentIndex; i < l; i++) {\n\t\t\t\tvar token = validTokens[i];\n\t\t\t\tvar content = token.content;\n\n\t\t\t\tif (token.type == 'punctuation') {\n\t\t\t\t\tif (open == content) {\n\t\t\t\t\t\tstackHeight++;\n\t\t\t\t\t} else if (close == content && !--stackHeight) {\n\t\t\t\t\t\treturn i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\twhile (currentIndex < l) {\n\t\t\tvar startToken = validTokens[currentIndex++];\n\n\t\t\t// add special aliases for mutation tokens\n\t\t\tif (startToken.type == 'keyword' && startToken.content == 'mutation') {\n\t\t\t\t// any array of the names of all input variables (if any)\n\t\t\t\tvar inputVariables = [];\n\n\t\t\t\tif (!isNotTokenType(['definition-mutation', 'punctuation']) && validTokens[currentIndex + 1].content == '(') {\n\t\t\t\t\t// definition\n\n\t\t\t\t\tcurrentIndex += 2; // skip 'definition-mutation' and 'punctuation'\n\n\t\t\t\t\tvar definitionEnd = findClosingBracket(\"(\", \")\");\n\t\t\t\t\tif (!definitionEnd) continue;\n\n\t\t\t\t\t// find all input variables\n\t\t\t\t\tfor (; currentIndex < definitionEnd; currentIndex++) {\n\t\t\t\t\t\tvar t = validTokens[currentIndex];\n\t\t\t\t\t\tif (t.type == 'variable') {\n\t\t\t\t\t\t\tt.alias = 'variable-input';\n\t\t\t\t\t\t\tinputVariables.push(t.content);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tcurrentIndex = definitionEnd + 1;\n\t\t\t\t}\n\n\t\t\t\tif (!isNotTokenType(['punctuation', 'property-query']) && validTokens[currentIndex].content == '{') {\n\t\t\t\t\t// skip opening bracket\n\t\t\t\t\tvalidTokens[++currentIndex].alias = 'property-mutation';\n\n\t\t\t\t\tif (inputVariables[0]) {\n\t\t\t\t\t\tvar mutationEnd = findClosingBracket(\"{\", \"}\");\n\t\t\t\t\t\t// give references to input variables a special alias\n\t\t\t\t\t\tif (mutationEnd) for (var i = currentIndex; i < mutationEnd; i++) {\n\t\t\t\t\t\t\tvar varToken = validTokens[i];\n\t\t\t\t\t\t\tif (varToken.type == 'variable' && inputVariables.indexOf(varToken.content) >= 0) {\n\t\t\t\t\t\t\t\tvarToken.alias = 'variable-input';\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn tokens;\n\t}\n};\n"],"names":["i"],"mappings":"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"}