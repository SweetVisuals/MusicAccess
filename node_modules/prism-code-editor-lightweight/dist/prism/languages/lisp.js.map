{"version":3,"file":"lisp.js","sources":["../../../src/prism/languages/lisp.js"],"sourcesContent":["import { languages, rest } from '../core.js';\nimport { clone } from '../utils/language.js';\n\n/**\n * Functions to construct regular expressions\n * e.g. (interactive ... or (interactive)\n *\n * @param {string} name\n * @returns {RegExp}\n */\nvar simple_form = name => RegExp(`(\\\\()(?:${name})(?=[\\\\s\\\\)])`);\n/**\n * booleans and numbers\n *\n * @param {string} pattern\n * @returns {RegExp}\n */\nvar primitive = pattern => RegExp(`([\\\\s([])(?:${pattern})(?=[\\\\s)])`);\n\n// Patterns in regular expressions\n\n// Symbol name. See https://www.gnu.org/software/emacs/manual/html_node/elisp/Symbol-Type.html\n// & and : are excluded as they are usually used for special purposes\nvar symbol = /(?!\\d)[~@$%{}\\w^!=<>/*+-]+/.source;\n// symbol starting with & used in function arguments\nvar marker = '&' + symbol;\n// Open parenthesis for look-behind\nvar par = '(\\\\()';\nvar endpar = '(?=\\\\))';\n// End the pattern with look-ahead space\nvar space = '(?=\\\\s)';\nvar nestedPar = /(?:[^()]|\\((?:[^()]|\\((?:[^()]|\\((?:[^()]|\\((?:[^()]|\\([^)]*\\))*\\))*\\))*\\))*\\))/.source;\n\nvar language = {\n\t// Three or four semicolons are considered a heading.\n\t// See https://www.gnu.org/software/emacs/manual/html_node/elisp/Comment-Tips.html\n\t'heading': {\n\t\tpattern: /;;;.*/,\n\t\talias: 'comment title'\n\t},\n\t'comment': /;.*/,\n\t'string': {\n\t\tpattern: /\"(?:\\\\.|[^\\\\\"])*\"/g,\n\t\tgreedy: true,\n\t\tinside: {\n\t\t\targument: /[-A-Z]+(?=[.,\\s])/,\n\t\t\tsymbol: RegExp('`' + symbol + \"'\")\n\t\t}\n\t},\n\t'quoted-symbol': {\n\t\tpattern: RegExp(\"#?'\" + symbol),\n\t\talias: 'variable symbol'\n\t},\n\t'lisp-property': {\n\t\tpattern: RegExp(':' + symbol),\n\t\talias: 'property'\n\t},\n\t'splice': {\n\t\tpattern: RegExp(',@?' + symbol),\n\t\talias: 'symbol variable'\n\t},\n\t'keyword': [\n\t\t{\n\t\t\tpattern: RegExp(\n\t\t\t\tpar +\n\t\t\t\t\t'(?:and|(?:cl-)?letf|cl-loop|con[ds]|error|if|(?:lexical-)?let\\\\*?|message|not|null|or|provide|require|setq|unless|use-package|when|while)' +\n\t\t\t\t\tspace\n\t\t\t),\n\t\t\tlookbehind: true\n\t\t},\n\t\t{\n\t\t\tpattern: RegExp(\n\t\t\t\tpar + '(?:append|by|collect|concat|do|finally|for|in|return)' + space\n\t\t\t),\n\t\t\tlookbehind: true\n\t\t},\n\t],\n\t'declare': {\n\t\tpattern: simple_form(/declare/.source),\n\t\tlookbehind: true,\n\t\talias: 'keyword'\n\t},\n\t'interactive': {\n\t\tpattern: simple_form(/interactive/.source),\n\t\tlookbehind: true,\n\t\talias: 'keyword'\n\t},\n\t'boolean': {\n\t\tpattern: primitive(/nil|t/.source),\n\t\tlookbehind: true\n\t},\n\t'number': {\n\t\tpattern: primitive(/[+-]?\\d+(?:\\.\\d*)?/.source),\n\t\tlookbehind: true\n\t},\n\t'defvar': {\n\t\tpattern: RegExp(par + 'def(?:const|custom|group|var)\\\\s+' + symbol),\n\t\tlookbehind: true,\n\t\tinside: {\n\t\t\t'keyword': /^def[a-z]+/,\n\t\t\t'variable': RegExp(symbol)\n\t\t}\n\t},\n\t'defun': {\n\t\tpattern: RegExp(`${par}(?:cl-)?(?:defmacro|defun\\\\*?)\\\\s+${symbol}\\\\s+\\\\(${nestedPar}*\\\\)`, 'g'),\n\t\tlookbehind: true,\n\t\tgreedy: true,\n\t\tinside: {\n\t\t\t'keyword': /^(?:cl-)?def\\S+/,\n\t\t\t// See below, this property needs to be defined later so that it can\n\t\t\t// reference the language object.\n\t\t\t'arguments': null,\n\t\t\t'function': {\n\t\t\t\tpattern: RegExp('(^\\\\s)' + symbol),\n\t\t\t\tlookbehind: true\n\t\t\t},\n\t\t\t'punctuation': /[()]/\n\t\t}\n\t},\n\t'lambda': {\n\t\tpattern: RegExp(par + 'lambda\\\\s+\\\\(\\\\s*(?:&?' + symbol + '(?:\\\\s+&?' + symbol + ')*\\\\s*)?\\\\)', 'g'),\n\t\tlookbehind: true,\n\t\tgreedy: true,\n\t\tinside: {\n\t\t\t'keyword': /^lambda/,\n\t\t\t// See below, this property needs to be defined later so that it can\n\t\t\t// reference the language object.\n\t\t\t'arguments': null,\n\t\t\t'punctuation': /[()]/\n\t\t}\n\t},\n\t'car': {\n\t\tpattern: RegExp(par + symbol),\n\t\tlookbehind: true\n\t},\n\t'punctuation': [\n\t\t// open paren, brackets, and close paren\n\t\t/['`,]\\(|[()[\\]]/,\n\t\t// cons\n\t\t{\n\t\t\tpattern: /(\\s)\\.(?!\\S)/,\n\t\t\tlookbehind: true\n\t\t},\n\t]\n};\n\nvar arg = {\n\t'lisp-marker': RegExp(marker),\n\t'varform': {\n\t\tpattern: RegExp(`\\\\(${symbol}\\\\s+(?=\\\\S)${nestedPar}*\\\\)`),\n\t\tinside: language\n\t},\n\t'argument': {\n\t\tpattern: RegExp('(^|[\\\\s(])' + symbol),\n\t\tlookbehind: true,\n\t\talias: 'variable'\n\t},\n\t[rest]: language\n};\n\nvar forms = '\\\\S+(?:\\\\s+\\\\S+)*';\n\nvar arglist = {\n\tpattern: RegExp(par + nestedPar + \"+\" + endpar),\n\tlookbehind: true,\n\tinside: {\n\t\t'rest-vars': {\n\t\t\tpattern: RegExp('&(?:body|rest)\\\\s+' + forms),\n\t\t\tinside: arg\n\t\t},\n\t\t'other-marker-vars': {\n\t\t\tpattern: RegExp('&(?:aux|optional)\\\\s+' + forms),\n\t\t\tinside: arg\n\t\t},\n\t\t'keys': {\n\t\t\tpattern: RegExp('&key\\\\s+' + forms + '(?:\\\\s+&allow-other-keys)?'),\n\t\t\tinside: arg\n\t\t},\n\t\t'argument': {\n\t\t\tpattern: RegExp(symbol),\n\t\t\talias: 'variable'\n\t\t},\n\t\t'punctuation': /[()]/\n\t}\n};\n\nlanguage['lambda'].inside.arguments = arglist;\n(language['defun'].inside.arguments = clone(arglist)).inside.sublist = arglist;\n\nlanguages['emacs-lisp'] = languages.emacs = languages.elisp = languages.lisp = language;\n"],"names":[],"mappings":"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"}