{"version":3,"file":"xquery.js","sources":["../../../src/prism/languages/xquery.js"],"sourcesContent":["import { languages, Token, tokenize, withoutTokenizer } from '../core.js';\nimport { extend } from '../utils/language.js';\nimport { re } from '../utils/shared.js';\nimport './markup.js';\n\nvar xquery = languages.xquery = extend('xml', {\n\t'xquery-comment': {\n\t\tpattern: /\\(:[\\s\\S]*?:\\)/g,\n\t\tgreedy: true,\n\t\talias: 'comment'\n\t},\n\t'string': {\n\t\tpattern: /\"(?:\"\"|[^\"])*\"|'(?:''|[^'])*'/g,\n\t\tgreedy: true\n\t},\n\t'extension': {\n\t\tpattern: /\\(#.+?#\\)/,\n\t\talias: 'symbol'\n\t},\n\t'variable': /\\$[-\\w:]+/,\n\t'axis': {\n\t\tpattern: /(^|[^-])(?:ancestor(?:-or-self)?|attribute|child|descendant(?:-or-self)?|following(?:-sibling)?|parent|preceding(?:-sibling)?|self)(?=::)/,\n\t\tlookbehind: true,\n\t\talias: 'operator'\n\t},\n\t'keyword-operator': {\n\t\tpattern: /(^|[^:-])\\b(?:and|castable as|eq|except|[gl][et]|i?div|instance of|intersect|is|mod|ne|or|union)\\b(?=$|[^:-])/,\n\t\tlookbehind: true,\n\t\talias: 'operator'\n\t},\n\t'keyword': {\n\t\tpattern: /(^|[^:-])\\b(?:as|ascending|at|base-uri|boundary-space|case|cast as|collation|construction|copy-namespaces|declare|default|descending|else|empty (?:greatest|least)|encoding|every|external|for|function|if|import|in|inherit|lax|let|map|module|namespace|no-inherit|no-preserve|option|order(?: by|ed|ing)?|preserve|return|satisfies|schema|some|stable|strict|strip|then|to|treat as|typeswitch|unordered|validate|variable|version|where|xquery)\\b(?=$|[^:-])/,\n\t\tlookbehind: true\n\t},\n\t'function': /[\\w-]+(?::[\\w-]+)*(?=\\s*\\()/,\n\t'xquery-element': {\n\t\tpattern: /(element\\s+)[\\w-]+(?::[\\w-]+)*/,\n\t\tlookbehind: true,\n\t\talias: 'tag'\n\t},\n\t'xquery-attribute': {\n\t\tpattern: /(attribute\\s+)[\\w-]+(?::[\\w-]+)*/,\n\t\tlookbehind: true,\n\t\talias: 'attr-name'\n\t},\n\t'builtin': {\n\t\tpattern: /(^|[^:-])\\b(?:attribute|comment|document|element|processing-instruction|text|xs:(?:ENTITIES|ENTITY|ID|IDREFS?|NCName|NMTOKENS?|NOTATION|Q?Name|anyAtomicType|anyType|anyURI|base64Binary|boolean|byte|date|dateTime|dayTimeDuration|decimal|double|duration|float|gDay|gMonth|gMonthDay|gYear|gYearMonth|hexBinary|int|integer|language|long|negativeInteger|nonNegativeInteger|nonPositiveInteger|normalizedString|positiveInteger|short|string|time|token|unsigned(?:Byte|Int|Long|Short)|untyped(?:Atomic)?|yearMonthDuration))\\b(?=$|[^:-])/,\n\t\tlookbehind: true\n\t},\n\t'number': /\\b\\d+(?:\\.\\d+)?(?:E[+-]?\\d+)?/,\n\t'operator': {\n\t\tpattern: /[=?|@*+]|\\.\\.?|:=|!=|<[=<]?|>[=>]?|(\\s)-(?!\\S)/,\n\t\tlookbehind: true\n\t},\n\t'punctuation': /[()[\\]{},:;/]/,\n\t[tokenize]: (code, grammar) => walkTokens(withoutTokenizer(code, grammar), code, 0)\n});\n\nvar tag = xquery.tag;\nvar attrValue = tag.inside['attr-value'][0];\nvar isText = token => token && (!token.type || token.type == 'plain-text');\n\n/**\n * @param {(string | Token)[]} tokens\n * @param {string} code\n * @param {number} position\n */\nvar walkTokens = (tokens, code, position) => {\n\tfor (var i = 0, openedTags = [], l = 0; i < tokens.length; i++) {\n\t\tvar token = tokens[i];\n\t\tvar length = token.length;\n\t\tvar type = token.type;\n\t\tvar notTagNorBrace = !type;\n\t\tvar last, tag, start, plainText, content;\n\n\t\tif (type && type != 'comment') {\n\t\t\tcontent = token.content;\n\t\t\tif (type == 'tag') {\n\t\t\t\t// We found a tag, now find its kind\n\t\t\t\tstart = content[0].length;\n\t\t\t\ttag = code.substr(position + start, content[1].length);\n\t\t\t\tif (start > 1) {\n\t\t\t\t\t// Closing tag\n\t\t\t\t\tif (l && openedTags[l - 1][0] == tag) {\n\t\t\t\t\t\t// Pop matching opening tag\n\t\t\t\t\t\tl--;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (content[content.length - 1].length < 2) {\n\t\t\t\t\t\t// Opening tag\n\t\t\t\t\t\topenedTags[l++] = [tag, 0];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (l && type == 'punctuation') {\n\t\t\t\tlast = openedTags[l - 1];\n\t\t\t\tif (content == '{') {\n\t\t\t\t\t// Ignore `{{`\n\t\t\t\t\tif (code[position + 1] == content) {\n\t\t\t\t\t\ttokens[i + 1] = content;\n\t\t\t\t\t\tnotTagNorBrace = true;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tlast[1]++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (last[1] && content == '}') last[1]--;\n\t\t\t\telse {\n\t\t\t\t\tnotTagNorBrace = true;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tnotTagNorBrace = true;\n\t\t\t}\n\t\t}\n\t\tif (notTagNorBrace && l && !openedTags[l - 1][1]) {\n\t\t\t// Here we are inside a tag, and not inside an XQuery expression.\n\t\t\t// That's plain text: drop any tokens matched.\n\t\t\tstart = position;\n\n\t\t\t// And merge text with adjacent text\n\t\t\tif (isText(tokens[i + 1])) {\n\t\t\t\tlength += tokens[i + 1].length;\n\t\t\t\ttokens.splice(i + 1, 1);\n\t\t\t}\n\t\t\tif (isText(tokens[i - 1])) {\n\t\t\t\tstart -= tokens[--i].length;\n\t\t\t\ttokens.splice(i, 1);\n\t\t\t}\n\n\t\t\tplainText = code.slice(start, position + length);\n\t\t\ttokens[i] = new Token('plain-text', plainText, plainText);\n\t\t}\n\t\tposition += length;\n\t}\n\treturn tokens;\n};\n\n// Allow for two levels of nesting\nvar expression = [/\\{(?!\\{)(?:[^{}]|\\{(?:[^{}]|\\{[^}]*\\})*\\})*\\}/.source];\n\ntag.pattern = re(/<\\/?(?!\\d)[^\\s/=>$<%]+(?:\\s+[^\\s/=>]+(?:\\s*=\\s*([\"'])(?:\\{\\{|<0>|(?!\\1)[^{])*\\1)?)*\\s*\\/?>/.source, expression, 'g');\nattrValue.pattern = re(/(=\\s*)([\"'])(?:\\{\\{|<0>|(?!\\2)[^{])*\\2/.source, expression, 'g');\nattrValue.inside['expression'] = {\n\tpattern: re(/((?:^|[^{])(?:\\{\\{)*)<0>/.source, expression),\n\tlookbehind: true,\n\talias: 'language-xquery',\n\tinside: xquery\n};\ndelete xquery['markup-bracket'];\n"],"names":["tag"],"mappings":"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"}