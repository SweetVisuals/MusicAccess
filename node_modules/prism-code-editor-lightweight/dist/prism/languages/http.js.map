{"version":3,"file":"http.js","sources":["../../../src/prism/languages/http.js"],"sourcesContent":["import { languages } from '../core.js';\n\n/**\n * @param {string} name\n * @param {string} lang\n */\nvar headerValueOf = (name, lang) => ({\n\tpattern: RegExp('(^(?:' + name + '):[ \\t]*)\\\\S[^]*', 'i'),\n\tlookbehind: true,\n\talias: lang && 'language-' + lang,\n\tinside: lang\n});\n\nvar http = languages.http = {\n\t'request-line': {\n\t\tpattern: /^(?:CONNECT|DELETE|GET|HEAD|OPTIONS|PATCH|POST|PRI|PUT|SEARCH|TRACE)\\s(?:https?:\\/)?\\/\\S*\\sHTTP\\/[\\d.]+/m,\n\t\tinside: {\n\t\t\t// HTTP Method\n\t\t\t'method': {\n\t\t\t\tpattern: /^\\w+/,\n\t\t\t\talias: 'property'\n\t\t\t},\n\t\t\t// Request Target e.g. http://example.com, /path/to/file\n\t\t\t'request-target': {\n\t\t\t\tpattern: /^(\\s)[h/]\\S*/,\n\t\t\t\tlookbehind: true,\n\t\t\t\talias: 'url',\n\t\t\t\tinside: 'uri'\n\t\t\t},\n\t\t\t// HTTP Version\n\t\t\t'http-version': {\n\t\t\t\tpattern: /(?!^)\\S+/,\n\t\t\t\talias: 'property'\n\t\t\t},\n\t\t}\n\t},\n\t'response-status': {\n\t\tpattern: /^HTTP\\/[\\d.]+ \\d+ .+/m,\n\t\tinside: {\n\t\t\t// HTTP Version\n\t\t\t'http-version': {\n\t\t\t\tpattern: /^\\S+/,\n\t\t\t\talias: 'property'\n\t\t\t},\n\t\t\t// Status Code\n\t\t\t'status-code': {\n\t\t\t\tpattern: /^( )\\d+(?= )/,\n\t\t\t\tlookbehind: true,\n\t\t\t\talias: 'number'\n\t\t\t},\n\t\t\t// Reason Phrase\n\t\t\t'reason-phrase': {\n\t\t\t\tpattern: /(?!^).+/,\n\t\t\t\talias: 'string'\n\t\t\t}\n\t\t}\n\t}\n};\n\n// Create a mapping of Content-Type headers to language definitions\n\n[\n\t'application/javascript',\n\t'application/json',\n\t'application/xml',\n\t'text/xml',\n\t'text/html',\n\t'text/css',\n\t'text/plain'\n].forEach(contentType => {\n\tvar lang = contentType.split('/')[1];\n\tvar pattern = contentType[10] && !lang[4]\n\t\t? '(?:' + contentType + '|\\\\w+/(?:[\\\\w.-]+\\\\+)+' + lang + '(?![\\\\w.+-]))' : contentType;\n\n\thttp[contentType.replace('/', '-')] = {\n\t\tpattern: RegExp('(content-type:\\\\s*'+ pattern + '(?:;.*)?(?:\\n[\\\\w-].*)*\\n)[^ \\t\\\\w-][^]*', 'i'),\n\t\tlookbehind: true,\n\t\talias: 'language-' + lang,\n\t\tinside: lang == 'json' ? languages.json || 'js' : lang\n\t};\n});\n\nhttp.header = {\n\tpattern: /^[\\w-]+:.+(?:\\n[ \\t].+)*/m,\n\tinside: {\n\t\t'header-value': [\n\t\t\theaderValueOf(/Content-Security-Policy/.source, 'csp'),\n\t\t\theaderValueOf(/Public-Key-Pins(?:-Report-Only)?/.source, 'hpkp'),\n\t\t\theaderValueOf(/Strict-Transport-Security/.source, 'hsts'),\n\t\t\theaderValueOf(/[^:]+/.source)\n\t\t],\n\t\t'header-name': {\n\t\t\tpattern: /^[^:]+/,\n\t\t\talias: 'keyword'\n\t\t},\n\t\t'punctuation': /^:/\n\t}\n};\n"],"names":[],"mappings":";AAMA,IAAI,gBAAgB,CAAC,MAAM,UAAU;AAAA,EACpC,SAAS,OAAO,UAAU,OAAO,mBAAoB,GAAG;AAAA,EACxD,YAAY;AAAA,EACZ,OAAO,QAAQ,cAAc;AAAA,EAC7B,QAAQ;AACT;AAEA,IAAI,OAAO,UAAU,OAAO;AAAA,EAC3B,gBAAgB;AAAA,IACf,SAAS;AAAA,IACT,QAAQ;AAAA;AAAA,MAEP,UAAU;AAAA,QACT,SAAS;AAAA,QACT,OAAO;AAAA,MACP;AAAA;AAAA,MAED,kBAAkB;AAAA,QACjB,SAAS;AAAA,QACT,YAAY;AAAA,QACZ,OAAO;AAAA,QACP,QAAQ;AAAA,MACR;AAAA;AAAA,MAED,gBAAgB;AAAA,QACf,SAAS;AAAA,QACT,OAAO;AAAA,MACP;AAAA,IACJ;AAAA,EACE;AAAA,EACD,mBAAmB;AAAA,IAClB,SAAS;AAAA,IACT,QAAQ;AAAA;AAAA,MAEP,gBAAgB;AAAA,QACf,SAAS;AAAA,QACT,OAAO;AAAA,MACP;AAAA;AAAA,MAED,eAAe;AAAA,QACd,SAAS;AAAA,QACT,YAAY;AAAA,QACZ,OAAO;AAAA,MACP;AAAA;AAAA,MAED,iBAAiB;AAAA,QAChB,SAAS;AAAA,QACT,OAAO;AAAA,MACX;AAAA,IACA;AAAA,EACA;AACA;AAIA;AAAA,EACC;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACD,EAAE,QAAQ,iBAAe;AACxB,MAAI,OAAO,YAAY,MAAM,GAAG,EAAE,CAAC;AACnC,MAAI,UAAU,YAAY,EAAE,KAAK,CAAC,KAAK,CAAC,IACrC,QAAQ,cAAc,2BAA2B,OAAO,kBAAkB;AAE7E,OAAK,YAAY,QAAQ,KAAK,GAAG,CAAC,IAAI;AAAA,IACrC,SAAS,OAAO,uBAAsB,UAAU,2CAA4C,GAAG;AAAA,IAC/F,YAAY;AAAA,IACZ,OAAO,cAAc;AAAA,IACrB,QAAQ,QAAQ,SAAS,UAAU,QAAQ,OAAO;AAAA,EAClD;AACF,CAAC;AAED,KAAK,SAAS;AAAA,EACb,SAAS;AAAA,EACT,QAAQ;AAAA,IACP,gBAAgB;AAAA,MACf,cAAc,2BAAkC,KAAK;AAAA,MACrD,cAAc,oCAA2C,MAAM;AAAA,MAC/D,cAAc,6BAAoC,MAAM;AAAA,MACxD,cAAc,OAAc;AAAA,IAC5B;AAAA,IACD,eAAe;AAAA,MACd,SAAS;AAAA,MACT,OAAO;AAAA,IACP;AAAA,IACD,eAAe;AAAA,EACjB;AACA;"}