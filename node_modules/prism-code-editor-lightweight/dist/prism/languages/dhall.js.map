{"version":3,"file":"dhall.js","sources":["../../../src/prism/languages/dhall.js"],"sourcesContent":["import { languages } from '../core.js';\n\n// ABNF grammar:\n// https://github.com/dhall-lang/dhall-lang/blob/master/standard/dhall.abnf\n\nvar expression = {\n\tpattern: /(^..)[\\s\\S]+(?=.)/,\n\tlookbehind: true,\n\talias: 'language-dhall'\n}\n\nexpression.inside = languages.dhall = {\n\t// Multi-line comments can be nested. E.g. {- foo {- bar -} -}\n\t// The multi-line pattern is essentially this:\n\t//   \\{-(?:[^-{]|-(?!\\})|\\{(?!-)|<SELF>)*-\\}\n\t'comment': /--.*|\\{-(?:[^-{]|-(?!\\})|\\{(?!-)|\\{-(?:[^-{]|-(?!\\})|\\{(?!-))*-\\})*-\\}/,\n\t'string': {\n\t\tpattern: /\"(?:\\\\.|[^\\\\\"])*\"|''(?:[^']|'(?!')|'''|''\\$\\{)*''(?!'|\\$)/g,\n\t\tgreedy: true,\n\t\tinside: {\n\t\t\t'interpolation': {\n\t\t\t\tpattern: /\\$\\{[^{}]*\\}/,\n\t\t\t\tinside: {\n\t\t\t\t\t'expression': expression,\n\t\t\t\t\t'punctuation': /.+/\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\t'label': {\n\t\tpattern: /`[^`]*`/g,\n\t\tgreedy: true\n\t},\n\t'url': {\n\t\t// https://github.com/dhall-lang/dhall-lang/blob/5fde8ef1bead6fb4e999d3c1ffe7044cd019d63a/standard/dhall.abnf#L596\n\t\tpattern: /\\bhttps?:\\/\\/[\\w.:%!$&'*+;=@~-]+(?:\\/[\\w.:%!$&'*+;=@~-]*)*(?:\\?[/?\\w.:%!$&'*+;=@~-]*)?/g,\n\t\tgreedy: true\n\t},\n\t'env': {\n\t\t// https://github.com/dhall-lang/dhall-lang/blob/5fde8ef1bead6fb4e999d3c1ffe7044cd019d63a/standard/dhall.abnf#L661\n\t\tpattern: /\\benv:(?:(?!\\d)\\w+|\"(?:\\\\.|[^\\\\\"=])*\")/g,\n\t\tgreedy: true,\n\t\tinside: {\n\t\t\t'function': /^env/,\n\t\t\t'operator': /^:/,\n\t\t\t'variable': /[\\s\\S]+/\n\t\t}\n\t},\n\t'hash': {\n\t\t// https://github.com/dhall-lang/dhall-lang/blob/5fde8ef1bead6fb4e999d3c1ffe7044cd019d63a/standard/dhall.abnf#L725\n\t\tpattern: /\\bsha256:[a-fA-F\\d]{64}\\b/,\n\t\tinside: {\n\t\t\t'function': /sha256/,\n\t\t\t'operator': /:/,\n\t\t\t'number': /[a-fA-F\\d]{64}/\n\t\t}\n\t},\n\n\t// https://github.com/dhall-lang/dhall-lang/blob/5fde8ef1bead6fb4e999d3c1ffe7044cd019d63a/standard/dhall.abnf#L359\n\t'keyword': /\\b(?:as|assert|else|forall|if|in|let|merge|missing|then|toMap|using|with)\\b|∀/,\n\t'builtin': /\\b(?:None|Some)\\b/,\n\n\t'boolean': /\\b(?:False|True)\\b/,\n\t'number': /\\bNaN\\b|-?\\bInfinity\\b|[+-]?\\b(?:0x[a-fA-F\\d]+|\\d+(?:\\.\\d+)?(?:e[+-]?\\d+)?)\\b/,\n\t'operator': /\\/\\\\|\\/\\/\\\\\\\\|===|[!=]=|\\/\\/|->|\\+\\+|&&|\\|\\||::|[+*#@:?=<>|\\\\∧⩓≡⫽λ→]/,\n\t'punctuation': /\\.\\.|[()[\\]{}.,/]/,\n\n\t// we'll just assume that every capital word left is a type name\n\t'class-name': /\\b[A-Z]\\w*\\b/\n};\n"],"names":[],"mappings":";AAKA,IAAI,aAAa;AAAA,EAChB,SAAS;AAAA,EACT,YAAY;AAAA,EACZ,OAAO;AACR;AAEA,WAAW,SAAS,UAAU,QAAQ;AAAA;AAAA;AAAA;AAAA,EAIrC,WAAW;AAAA,EACX,UAAU;AAAA,IACT,SAAS;AAAA,IACT,QAAQ;AAAA,IACR,QAAQ;AAAA,MACP,iBAAiB;AAAA,QAChB,SAAS;AAAA,QACT,QAAQ;AAAA,UACP,cAAc;AAAA,UACd,eAAe;AAAA,QACpB;AAAA,MACA;AAAA,IACA;AAAA,EACE;AAAA,EACD,SAAS;AAAA,IACR,SAAS;AAAA,IACT,QAAQ;AAAA,EACR;AAAA,EACD,OAAO;AAAA;AAAA,IAEN,SAAS;AAAA,IACT,QAAQ;AAAA,EACR;AAAA,EACD,OAAO;AAAA;AAAA,IAEN,SAAS;AAAA,IACT,QAAQ;AAAA,IACR,QAAQ;AAAA,MACP,YAAY;AAAA,MACZ,YAAY;AAAA,MACZ,YAAY;AAAA,IACf;AAAA,EACE;AAAA,EACD,QAAQ;AAAA;AAAA,IAEP,SAAS;AAAA,IACT,QAAQ;AAAA,MACP,YAAY;AAAA,MACZ,YAAY;AAAA,MACZ,UAAU;AAAA,IACb;AAAA,EACE;AAAA;AAAA,EAGD,WAAW;AAAA,EACX,WAAW;AAAA,EAEX,WAAW;AAAA,EACX,UAAU;AAAA,EACV,YAAY;AAAA,EACZ,eAAe;AAAA;AAAA,EAGf,cAAc;AACf;"}