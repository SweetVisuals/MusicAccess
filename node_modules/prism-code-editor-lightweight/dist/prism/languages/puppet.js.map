{"version":3,"file":"puppet.js","sources":["../../../src/prism/languages/puppet.js"],"sourcesContent":["import { languages, rest } from '../core.js';\nimport { boolean } from '../utils/patterns.js';\n\nvar interpolation = [\n\t{\n\t\t// Allow for one nested level of braces inside interpolation\n\t\tpattern: /(^|[^\\\\])\\$\\{(?:[^{}\"']|\\{[^}]*\\}|([\"'])(?:\\\\[\\s\\S]|(?!\\2)[^\\\\])*\\2)+\\}/,\n\t\tlookbehind: true,\n\t\tinside: {\n\t\t\t'short-variable': {\n\t\t\t\t// Negative look-ahead prevent wrong highlighting of functions\n\t\t\t\tpattern: /(^\\$\\{)(?!\\w+\\()(?:::)?\\w+(?:::\\w+)*/,\n\t\t\t\tlookbehind: true,\n\t\t\t\talias: 'variable',\n\t\t\t\tinside: {\n\t\t\t\t\t'punctuation': /::/\n\t\t\t\t}\n\t\t\t},\n\t\t\t'delimiter': {\n\t\t\t\tpattern: /^\\$/,\n\t\t\t\talias: 'variable'\n\t\t\t}\n\t\t}\n\t},\n\t{\n\t\tpattern: /(^|[^\\\\])\\$(?:::)?\\w+(?:::\\w+)*/,\n\t\tlookbehind: true,\n\t\talias: 'variable',\n\t\tinside: {\n\t\t\t'punctuation': /::/\n\t\t}\n\t}\n];\n\ninterpolation[0].inside[rest] = languages.puppet = {\n\t'heredoc': [\n\t\t// Matches the content of a quoted heredoc string (subject to interpolation)\n\t\t{\n\t\t\tpattern: /(@\\(\"([^\\n\"/):]+)\"(?:\\/[nrts$uL]*)?\\).*\\n)(?:.*\\n)*?[ \\t]*(?:\\|[ \\t]*)?(?:-[ \\t]*)?\\2/,\n\t\t\tlookbehind: true,\n\t\t\talias: 'string',\n\t\t\tinside: {\n\t\t\t\t// Matches the end tag\n\t\t\t\t'punctuation': /(?!\\s).*\\S(?= *$)/,\n\t\t\t\t// See interpolation below\n\t\t\t\t'interpolation': interpolation\n\t\t\t}\n\t\t},\n\t\t// Matches the content of an unquoted heredoc string (no interpolation)\n\t\t{\n\t\t\tpattern: /(@\\(([^\\n\"/):]+)(?:\\/[nrts$uL]*)?\\).*\\n)(?:.*\\n)*?[ \\t]*(?:\\|[ \\t]*)?(?:-[ \\t]*)?\\2/g,\n\t\t\tlookbehind: true,\n\t\t\tgreedy: true,\n\t\t\talias: 'string',\n\t\t\tinside: {\n\t\t\t\t// Matches the end tag\n\t\t\t\t'punctuation': /(?!\\s).*\\S(?= *$)/\n\t\t\t}\n\t\t},\n\t\t// Matches the start tag of heredoc strings\n\t\t{\n\t\t\tpattern: /@\\(\"?(?:[^\\n\"/):]+)\"?(?:\\/[nrts$uL]*)?\\)/,\n\t\t\talias: 'string',\n\t\t\tinside: {\n\t\t\t\t'punctuation': /(?![(@]).+(?=.)/\n\t\t\t}\n\t\t}\n\t],\n\t'multiline-comment': {\n\t\tpattern: /\\/\\*[\\s\\S]*?\\*\\//g,\n\t\tgreedy: true,\n\t\talias: 'comment'\n\t},\n\t'regex': {\n\t\t// Must be prefixed with the keyword \"node\" or a non-word char\n\t\tpattern: /(\\bnode\\s+|[~=([{,]\\s*|[=+]>\\s*|^\\s*)\\/(?:\\\\[\\s\\S]|[^\\\\/])+\\/(?:[imx]+\\b|\\B)/g,\n\t\tlookbehind: true,\n\t\tgreedy: true,\n\t\tinside: {\n\t\t\t// Extended regexes must have the x flag. They can contain single-line comments.\n\t\t\t'extended-regex': {\n\t\t\t\tpattern: /^\\/(?:\\\\[\\s\\S]|[^\\\\/])+\\/[im]*x[im]*$/,\n\t\t\t\tinside: {\n\t\t\t\t\t'comment': /#.*/\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\t'comment': {\n\t\tpattern: /#.*/g,\n\t\tgreedy: true,\n\t},\n\t'string': {\n\t\t// Allow for one nested level of double quotes inside interpolation\n\t\tpattern: /([\"'])(?:\\$\\{(?:[^}\"']|([\"'])(?:\\\\[\\s\\S]|(?!\\2)[^\\\\])*\\2)+\\}|\\$(?!\\{)|\\\\[\\s\\S]|(?!\\1)[^\\\\$])*\\1/g,\n\t\tgreedy: true,\n\t\tinside: {\n\t\t\t'double-quoted': {\n\t\t\t\tpattern: /^\"[\\s\\S]*\"$/,\n\t\t\t\tinside: {\n\t\t\t\t\t'interpolation': interpolation\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\t'variable': {\n\t\tpattern: /\\$(?:::)?\\w+(?:::\\w+)*/,\n\t\tinside: {\n\t\t\t'punctuation': /::/\n\t\t}\n\t},\n\t'attr-name': /(?:\\b\\w+|\\*)(?=\\s*=>)/,\n\t'function': [\n\t\t{\n\t\t\tpattern: /(\\.)(?!\\d)\\w+/,\n\t\t\tlookbehind: true\n\t\t},\n\t\t/\\b(?:contain|debug|err|fail|include|info|notice|realize|require|tag|warning)\\b|\\b(?!\\d)\\w+(?=\\()/\n\t],\n\t'number': /\\b(?:0x[a-f\\d]+|\\d+(?:\\.\\d+)?(?:e-?\\d+)?)\\b/i,\n\t'boolean': boolean,\n\t// Includes words reserved for future use\n\t'keyword': /\\b(?:application|attr|case|class|consumes|default|define|else|elsif|function|if|import|inherits|node|private|produces|type|undef|unless)\\b/,\n\t'datatype': {\n\t\tpattern: /\\b(?:Any|Array|Boolean|Callable|Catalogentry|Class|Collection|Data|Default|Enum|Float|Hash|Integer|NotUndef|Numeric|Optional|Pattern|Regexp|Resource|Runtime|Scalar|String|Struct|Tuple|Type|Undef|Variant)\\b/,\n\t\talias: 'symbol'\n\t},\n\t'operator': /=[=~>]?|![=~]?|<<\\|?|<[=~|-]?|>[>=]?|->?|~>|\\|>?>?|[%/*+?]|\\b(?:and|in|or)\\b/,\n\t'punctuation': /[()[\\]{}.,;]|:+/\n};\n"],"names":[],"mappings":";;AAGA,IAAI,gBAAgB;AAAA,EACnB;AAAA;AAAA,IAEC,SAAS;AAAA,IACT,YAAY;AAAA,IACZ,QAAQ;AAAA,MACP,kBAAkB;AAAA;AAAA,QAEjB,SAAS;AAAA,QACT,YAAY;AAAA,QACZ,OAAO;AAAA,QACP,QAAQ;AAAA,UACP,eAAe;AAAA,QACpB;AAAA,MACI;AAAA,MACD,aAAa;AAAA,QACZ,SAAS;AAAA,QACT,OAAO;AAAA,MACX;AAAA,IACA;AAAA,EACE;AAAA,EACD;AAAA,IACC,SAAS;AAAA,IACT,YAAY;AAAA,IACZ,OAAO;AAAA,IACP,QAAQ;AAAA,MACP,eAAe;AAAA,IAClB;AAAA,EACA;AACA;AAEA,cAAc,CAAC,EAAE,OAAO,IAAI,IAAI,UAAU,SAAS;AAAA,EAClD,WAAW;AAAA;AAAA,IAEV;AAAA,MACC,SAAS;AAAA,MACT,YAAY;AAAA,MACZ,OAAO;AAAA,MACP,QAAQ;AAAA;AAAA,QAEP,eAAe;AAAA;AAAA,QAEf,iBAAiB;AAAA,MACrB;AAAA,IACG;AAAA;AAAA,IAED;AAAA,MACC,SAAS;AAAA,MACT,YAAY;AAAA,MACZ,QAAQ;AAAA,MACR,OAAO;AAAA,MACP,QAAQ;AAAA;AAAA,QAEP,eAAe;AAAA,MACnB;AAAA,IACG;AAAA;AAAA,IAED;AAAA,MACC,SAAS;AAAA,MACT,OAAO;AAAA,MACP,QAAQ;AAAA,QACP,eAAe;AAAA,MACnB;AAAA,IACA;AAAA,EACE;AAAA,EACD,qBAAqB;AAAA,IACpB,SAAS;AAAA,IACT,QAAQ;AAAA,IACR,OAAO;AAAA,EACP;AAAA,EACD,SAAS;AAAA;AAAA,IAER,SAAS;AAAA,IACT,YAAY;AAAA,IACZ,QAAQ;AAAA,IACR,QAAQ;AAAA;AAAA,MAEP,kBAAkB;AAAA,QACjB,SAAS;AAAA,QACT,QAAQ;AAAA,UACP,WAAW;AAAA,QAChB;AAAA,MACA;AAAA,IACA;AAAA,EACE;AAAA,EACD,WAAW;AAAA,IACV,SAAS;AAAA,IACT,QAAQ;AAAA,EACR;AAAA,EACD,UAAU;AAAA;AAAA,IAET,SAAS;AAAA,IACT,QAAQ;AAAA,IACR,QAAQ;AAAA,MACP,iBAAiB;AAAA,QAChB,SAAS;AAAA,QACT,QAAQ;AAAA,UACP,iBAAiB;AAAA,QACtB;AAAA,MACA;AAAA,IACA;AAAA,EACE;AAAA,EACD,YAAY;AAAA,IACX,SAAS;AAAA,IACT,QAAQ;AAAA,MACP,eAAe;AAAA,IAClB;AAAA,EACE;AAAA,EACD,aAAa;AAAA,EACb,YAAY;AAAA,IACX;AAAA,MACC,SAAS;AAAA,MACT,YAAY;AAAA,IACZ;AAAA,IACD;AAAA,EACA;AAAA,EACD,UAAU;AAAA,EACV,WAAW;AAAA;AAAA,EAEX,WAAW;AAAA,EACX,YAAY;AAAA,IACX,SAAS;AAAA,IACT,OAAO;AAAA,EACP;AAAA,EACD,YAAY;AAAA,EACZ,eAAe;AAChB;"}