{"version":3,"file":"cue.js","sources":["../../../src/prism/languages/cue.js"],"sourcesContent":["import { languages } from '../core.js';\nimport { re } from '../utils/shared.js';\n\n// https://cuelang.org/docs/references/spec/\n\n// eslint-disable-next-line regexp/strict\nvar stringEscape = /\\\\(?:(?!\\2)|\\2(?:[^()\\n]|\\([^()]*\\)))/.source;\nvar stringLiteral = re(`(^|[^#\"'\\\\\\\\])(#*)(?:\"\"\"(?:[^\\\\\\\\\"]|\"(?!\"\"\\\\2)|<0>)*\"\"\"|'''(?:[^\\\\\\\\']|'(?!''\\\\2)|<0>)*'''|\"(?:[^\\\\\\\\\\n\"]|\"(?!\\\\2)|<0>)*\"|'(?:[^\\\\\\\\\\n']|'(?!\\\\2)|<0>)*')(?![\"'])\\\\2`, [stringEscape], 'g');\n\nvar expression = {\n\tpattern: /[\\s\\S]+/\n}\n\nexpression.inside = languages.cue = {\n\t'comment': /\\/\\/.*/,\n\t'string-literal': {\n\t\tpattern: stringLiteral,\n\t\tlookbehind: true,\n\t\tgreedy: true,\n\t\tinside: {\n\t\t\t// I'm using dirty hack here. We have to know the number hashes at the start of the string somehow,\n\t\t\t// but we can't look back. So instead, we will use a lookahead, go to the end of the string, and\n\t\t\t// capture the hashes at the end of the string.\n\t\t\t'escape': {\n\t\t\t\tpattern: /(?=[\\s\\S]*[\"'](#*)$)\\\\\\1(?:U[a-fA-F\\d]{1,8}|u[a-fA-F\\d]{1,4}|x[a-fA-F\\d]{1,2}|\\d{2,3}|[^(])/g,\n\t\t\t\tgreedy: true,\n\t\t\t\talias: 'string'\n\t\t\t},\n\t\t\t'interpolation': {\n\t\t\t\tpattern: /(?=[\\s\\S]*[\"'](#*)$)\\\\\\1\\([^()]*\\)/g,\n\t\t\t\tgreedy: true,\n\t\t\t\tinside: {\n\t\t\t\t\t'punctuation': /^\\\\#*\\(|\\)$/,\n\t\t\t\t\t'expression': expression\n\t\t\t\t}\n\t\t\t},\n\t\t\t'string': /[\\s\\S]+/\n\t\t}\n\t},\n\n\t'keyword': {\n\t\tpattern: /(^|[^$\\w])(?:for|if|import|in|let|null|package)(?![$\\w])/,\n\t\tlookbehind: true\n\t},\n\t'boolean': {\n\t\tpattern: /(^|[^$\\w])(?:false|true)(?![$\\w])/,\n\t\tlookbehind: true\n\t},\n\t'builtin': {\n\t\tpattern: /(^|[^$\\w])(?:bool|bytes|float(?:32|64)?|u?int(?:8|16|32|64|128)?|number|rune|string)(?![$\\w])/,\n\t\tlookbehind: true\n\t},\n\n\t'attribute': {\n\t\tpattern: /@[$\\w]+(?=\\s*\\()/,\n\t\talias: 'function'\n\t},\n\t'function': {\n\t\tpattern: /(^|[^$\\w])[a-z_$][$\\w]*(?=\\s*\\()/i,\n\t\tlookbehind: true\n\t},\n\n\t'number': {\n\t\tpattern: /(^|[^$\\w.])(?:0b[01]+(?:_[01]+)*|0o[0-7]+(?:_[0-7]+)*|0[xX][a-fA-F\\d]+(?:_[a-fA-F\\d]+)*|(?:\\d+(?:_\\d+)*(?:\\.(?:\\d+(?:_\\d+)*)?)?|\\.\\d+(?:_\\d+)*)(?:[eE][+-]?\\d+(?:_\\d+)*)?(?:[KMGTP]i?)?)(?![$\\w])/,\n\t\tlookbehind: true\n\t},\n\n\t'operator': /\\.{3}|_\\|_|&&?|\\|\\|?|[!=]~|[<>!=]=?|[?/*+-]/,\n\t'punctuation': /[()[\\]{}.,:]/\n};\n"],"names":[],"mappings":";;AAMA,IAAI,eAAe;AACnB,IAAI,gBAAgB,GAAG;AAAA;AAAA,iCAAwK,CAAC,YAAY,GAAG,GAAG;AAElN,IAAI,aAAa;AAAA,EAChB,SAAS;AACV;AAEA,WAAW,SAAS,UAAU,MAAM;AAAA,EACnC,WAAW;AAAA,EACX,kBAAkB;AAAA,IACjB,SAAS;AAAA,IACT,YAAY;AAAA,IACZ,QAAQ;AAAA,IACR,QAAQ;AAAA;AAAA;AAAA;AAAA,MAIP,UAAU;AAAA,QACT,SAAS;AAAA,QACT,QAAQ;AAAA,QACR,OAAO;AAAA,MACP;AAAA,MACD,iBAAiB;AAAA,QAChB,SAAS;AAAA,QACT,QAAQ;AAAA,QACR,QAAQ;AAAA,UACP,eAAe;AAAA,UACf,cAAc;AAAA,QACnB;AAAA,MACI;AAAA,MACD,UAAU;AAAA,IACb;AAAA,EACE;AAAA,EAED,WAAW;AAAA,IACV,SAAS;AAAA,IACT,YAAY;AAAA,EACZ;AAAA,EACD,WAAW;AAAA,IACV,SAAS;AAAA,IACT,YAAY;AAAA,EACZ;AAAA,EACD,WAAW;AAAA,IACV,SAAS;AAAA,IACT,YAAY;AAAA,EACZ;AAAA,EAED,aAAa;AAAA,IACZ,SAAS;AAAA,IACT,OAAO;AAAA,EACP;AAAA,EACD,YAAY;AAAA,IACX,SAAS;AAAA,IACT,YAAY;AAAA,EACZ;AAAA,EAED,UAAU;AAAA,IACT,SAAS;AAAA,IACT,YAAY;AAAA,EACZ;AAAA,EAED,YAAY;AAAA,EACZ,eAAe;AAChB;"}