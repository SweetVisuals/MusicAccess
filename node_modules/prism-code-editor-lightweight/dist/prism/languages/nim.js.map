{"version":3,"file":"nim.js","sources":["../../../src/prism/languages/nim.js"],"sourcesContent":["import { languages } from '../core.js';\n\nlanguages.nim = {\n\t'comment': {\n\t\tpattern: /#.*/g,\n\t\tgreedy: true\n\t},\n\t'string': {\n\t\t// Double-quoted strings can be prefixed by an identifier (Generalized raw string literals)\n\t\tpattern: /(?:\\b(?!\\d)(?:\\w|\\\\x[89a-fA-F][a-fA-F\\d])+)?(?:\"\"\"[\\s\\S]*?\"\"\"(?!\")|\"(?:\\\\[\\s\\S]|\"\"|[^\\\\\"])*\")/g,\n\t\tgreedy: true\n\t},\n\t'char': {\n\t\t// Character literals are handled specifically to prevent issues with numeric type suffixes\n\t\tpattern: /'(?:\\\\(?:\\d+|x[a-fA-F\\d]{0,2}|.)|[^'])'/g,\n\t\tgreedy: true\n\t},\n\n\t'function': {\n\t\tpattern: /(?:(?!\\d)(?:\\w|\\\\x[89a-fA-F][a-fA-F\\d])+|`[^\\n`]+`)\\*?(?:\\[[^\\]]+\\])?(?=\\s*\\()/g,\n\t\tgreedy: true,\n\t\tinside: {\n\t\t\t'operator': /\\*$/\n\t\t}\n\t},\n\t// We don't want to highlight operators (and anything really) inside backticks\n\t'identifier': {\n\t\tpattern: /`[^\\n`]+`/g,\n\t\tgreedy: true,\n\t\tinside: {\n\t\t\t'punctuation': /`/\n\t\t}\n\t},\n\n\t// The negative look ahead prevents wrong highlighting of the .. operator\n\t'number': /\\b(?:0[xXoObB][a-fA-F\\d_]+|\\d[\\d_]*(?:(?!\\.\\.)\\.[\\d_]*)?(?:[eE][+-]?\\d[\\d_]*)?)(?:'?[iuf]\\d*)?/,\n\t'keyword': /\\b(?:addr|asm?|atomic|bind|block|break|cas[et]|concept|const|continue|converter|defer|discard|distinct|do|elif|else|end|enum|except|export|finally|for|from|func|generic|if|import|include|interface|iterator|let|macro|method|mixin|nil|object|out|proc|ptr|raise|ref|return|static|template|try|tuple|type|using|var|when|while|with|without|yield)\\b/,\n\t'operator': {\n\t\t// Look behind and look ahead prevent wrong highlighting of punctuations [. .] {. .} (. .)\n\t\t// but allow the slice operator .. to take precedence over them\n\t\t// One can define his own operators in Nim so all combination of operators might be an operator.\n\t\tpattern: /(^|[({\\[](?=\\.\\.)|(?![({\\[]\\.).)(?:(?:[\\\\@$~?:%&|^!=<>/*+-]|\\.\\.|\\.(?![)}\\]]))+|\\b(?:and|div|in|isnot|is|mod|notin|not|of|sh[lr]|x?or)\\b)/m,\n\t\tlookbehind: true\n\t},\n\t'punctuation': /[({[]\\.|\\.[)}\\]]|[`()[\\]{},:]/\n};\n"],"names":[],"mappings":";AAEA,UAAU,MAAM;AAAA,EACf,WAAW;AAAA,IACV,SAAS;AAAA,IACT,QAAQ;AAAA,EACR;AAAA,EACD,UAAU;AAAA;AAAA,IAET,SAAS;AAAA,IACT,QAAQ;AAAA,EACR;AAAA,EACD,QAAQ;AAAA;AAAA,IAEP,SAAS;AAAA,IACT,QAAQ;AAAA,EACR;AAAA,EAED,YAAY;AAAA,IACX,SAAS;AAAA,IACT,QAAQ;AAAA,IACR,QAAQ;AAAA,MACP,YAAY;AAAA,IACf;AAAA,EACE;AAAA;AAAA,EAED,cAAc;AAAA,IACb,SAAS;AAAA,IACT,QAAQ;AAAA,IACR,QAAQ;AAAA,MACP,eAAe;AAAA,IAClB;AAAA,EACE;AAAA;AAAA,EAGD,UAAU;AAAA,EACV,WAAW;AAAA,EACX,YAAY;AAAA;AAAA;AAAA;AAAA,IAIX,SAAS;AAAA,IACT,YAAY;AAAA,EACZ;AAAA,EACD,eAAe;AAChB;"}