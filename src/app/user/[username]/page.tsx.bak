"use client";

import { useState, useEffect, useCallback, useRef } from "react";
import { useParams } from "next/navigation";
import { useAuth } from "@/contexts/auth-context";
import useProfile from "@/hooks/useProfile";
import { Profile, Project } from "@/lib/types";
import ProfileHeader from "@/components/profile/ProfileHeader";
import ProfileInfo from "@/components/profile/ProfileInfo";
import ProfileContent from "@/components/profile/ProfileContent";

import { supabase } from "@/lib/supabase";
import { UploadDialog } from "@/components/profile/UploadDialog";
import useUserData from "@/hooks/useUserData";
import { PageLoading } from "@/components/ui/page-loading";
import { formatDuration } from "@/lib/utils";

type UserProfile = Profile & {
  role: string;
  streams: number;
  gems: number;
};

export default function ProfilePage() {
  const { user: authUser } = useAuth();
  const { profile, stats, loading, error, updateProfile: updateProfileHook, fetchProfile } = useProfile();
  const { fetchStorageUsage } = useUserData();
  const params = useParams();
  const username = params.username as string;

  // Use refs to track cleanup state
  const isComponentMounted = useRef(true);
  const abortControllerRef = useRef<AbortController | null>(null);

  const [projects, setProjects] = useState<Project[]>([]);
  const [playlists, setPlaylists] = useState<any[]>([]);
  const [albums, setAlbums] = useState<any[]>([]);
  const [userProfile, setUserProfile] = useState<UserProfile | null>(null);
  const [uploadType, setUploadType] = useState<'avatar' | 'banner' | null>(null);
  const [showCreateProjectDialog, setShowCreateProjectDialog] = useState(false);
  const [showCreateSoundpackDialog, setShowCreateSoundpackDialog] = useState(false);
  const [isInitialLoading, setIsInitialLoading] = useState(true);
  const [currentError, setCurrentError] = useState<string | null>(null);

  // Cleanup on unmount
  useEffect(() => {
    return () => {
      console.log('[ProfilePage] Component unmounting, cleaning up...');
      isComponentMounted.current = false;
      if (abortControllerRef.current) {
        abortControllerRef.current.abort();
      }
    };
  }, []);

  // Reset state when username changes
  useEffect(() => {
    console.log('[ProfilePage] Username changed to:', username, 'Profile:', profile);

    // Cancel any ongoing operations
    if (abortControllerRef.current) {
      abortControllerRef.current.abort();
    }

    // If username is undefined (e.g., initial render before params are available),
    // we should not proceed with fetching, but also not show an error immediately.
    // The `fetchUserData` useEffect will handle the `!username` case.
    if (!username) {
      setIsInitialLoading(true); // Keep loading state if username is not yet available
      return;
    }
>>>>>>>

    // Reset loading and error states
    setIsInitialLoading(true);
    setCurrentError(null);
    setUserProfile(null);
    setProjects([]);
    setPlaylists([]);
    setAlbums([]);
  }, [username]);

  const updateProfile = async (updates: Partial<Profile>) => {
    if (!userProfile?.id) return;
    await updateProfileHook({ ...updates, id: userProfile.id });
    useProfile.getState().fetchProfile(userProfile.id);
    await fetchStorageUsage(userProfile.id);
  };

  const handleUploadSuccess = async (publicUrl: string) => {
    console.log('handleUploadSuccess called with publicUrl:', publicUrl);
    console.log('userProfile before update:', userProfile);
    if (userProfile?.id && uploadType) {
      await updateProfile({
        [uploadType === 'avatar' ? 'profile_url' : 'banner_url']: publicUrl,
      });
      console.log('userProfile after update (should be updated by hook):', profile);
      useProfile.getState().fetchProfile(userProfile.id);
      await fetchStorageUsage(userProfile.id);
    }
  };

  const handleUploadDialogClose = (open: boolean) => {
    setUploadType(null);
  };

  useEffect(() => {
    let isMounted = true;
    const abortController = new AbortController();
    abortControllerRef.current = abortController;

    const fetchUserData = async () => {
      if (!username) {
        console.log('[ProfilePage] No username, skipping fetchUserData');
        if (isMounted) setIsInitialLoading(false);
        return;
      }

      // Check if the request was aborted
      if (abortControllerRef.current?.signal.aborted) {
        return;
      }

      try {
        if (isMounted) {
          setIsInitialLoading(true);
          setCurrentError(null);
        }
        console.log('ProfilePage: Fetching user data for username:', username);

        const { data: userData, error: userError } = await supabase
          .from('profiles')
          .select('id')
          .eq('username', username)
          .single();

        // Check if component is still mounted and request wasn't aborted
        if (!isMounted || abortControllerRef.current?.signal.aborted) return;

        if (userError) {
          console.error('ProfilePage: Error fetching user data:', userError);
          setCurrentError(userError.message || 'User not found');
          setIsInitialLoading(false);
          return;
        }

        console.log('ProfilePage: Found user data:', userData);
        if (userData && userData.id) {
          console.log('ProfilePage: Fetching profile for user ID:', userData.id);
          // Fetch profile data using the hook instead of direct query
          await fetchProfile(userData.id);
          console.log('ProfilePage: Profile fetch completed');
        } else {
          console.error('ProfilePage: No user data or ID found for username:', username);
          setCurrentError('User not found');
        }
      } catch (error) {
        // Don't update state if component is unmounted or request was aborted
        if (!isMounted || abortControllerRef.current?.signal.aborted) return;

        console.error('Error fetching user data by username:', error);
        setCurrentError(error instanceof Error ? error.message : 'An unexpected error occurred');
      } finally {
        if (isMounted && !abortControllerRef.current?.signal.aborted) {
          setIsInitialLoading(false);
        }
      }
    };

    fetchUserData();

    return () => {
      console.log('[ProfilePage] Cleanup: aborting fetch for username:', username);
      isMounted = false;
      abortController.abort();
      abortControllerRef.current = null;
    };
  }, [username, fetchProfile]);

  const fetchUserContent = useCallback(async (abortSignal?: AbortSignal) => {
    if (!profile?.id) return;

    // Check if the operation was aborted
    if (abortControllerRef.current?.signal.aborted) {
      console.log('[fetchUserContent] Aborted for profile:', profile.id);
      return;
    }

    try {
      console.log('[ProfilePage] Starting fetch for profile:', profile.id);

      // Fetch projects with their audio tracks using a join query
      const { data: projectsData, error: projectsError } = await supabase
        .from('projects')
        .select(
          `
           *,
           profiles!inner(*),
           audio_tracks!left(*)
         `
        )
        .or(`user_id.eq.${profile.id},is_public.eq.true`)
        .order('created_at', { ascending: false });

      // Check for abort after async operation
      if (abortControllerRef.current?.signal.aborted) {
        return;
      }

      if (projectsError) {
        console.error('Projects query error:', projectsError);
        throw projectsError;
      }

      console.log('Fetched projects with tracks:', {
        count: projectsData?.length,
        sample: projectsData?.[0],
      });

      // Process the projects to include both files and audio_tracks for compatibility
      const projectsWithTracks = (projectsData || []).map((project) => {
        // Extract audio tracks from the joined data
        const audioTracks = project.audio_tracks || [];

        // Convert audio_tracks to the expected format for ProjectCard
        const formattedTracks = audioTracks.map((track: any) => ({
          ...track,
          id: track.id,
          user_id: userProfile?.id, // Ensure user_id is included
          title: track.title,
          audio_url: track.audio_url,
          duration: track.duration_seconds, // Pass as number, format in ProjectCard if needed for display
          price: track.price || 0,
          allow_download: track.allow_download || false,
        }));

        return {
          ...project,
          files: [], // Keep empty files array for compatibility
          audio_tracks: formattedTracks,
        };
      });

      console.log('Final projects with tracks:', {
        count: projectsWithTracks.length,
        projects: projectsWithTracks.map((p) => ({
          title: p.title,
          trackCount: p.audio_tracks.length,
          tracks: p.audio_tracks,
        })),
      });

      // Check for abort before next async operations
      if (abortControllerRef.current?.signal.aborted) {
        return;
      }

      // Then fetch playlists and albums in parallel
      const [
        { data: playlistsData, error: playlistsError },
        { data: albumsData, error: albumsError },
      ] = await Promise.all([
        supabase.from('playlists').select('*').eq('user_id', profile.id),
        supabase.from('albums').select('*').eq('user_id', profile.id),
      ]);

      // Final abort check before updating state
      if (abortControllerRef.current?.signal.aborted) {
        return;
      }

      if (playlistsError) throw playlistsError;
      if (albumsError) throw albumsError;

      setProjects(projectsWithTracks || []);
      setPlaylists(playlistsData || []);
      setAlbums(albumsData || []);

      console.log('[fetchUserContent] Completed successfully for profile:', profile.id);
    } catch (err) {
      // Don't log errors if the operation was aborted
      if (abortControllerRef.current?.signal.aborted) {
        return;
      }
      console.error('Error fetching user content:', err);
    }
  }, [profile?.id]);

  useEffect(() => {
    console.log('[ProfilePage] useEffect - fetchUserContent dependency triggered');
    let isMounted = true;
    const abortController = new AbortController();

    const fetchContent = async () => {
      if (!profile?.id || !isMounted || abortControllerRef.current?.signal.aborted) return;

      try {
        await fetchUserContent(abortController.signal);
      } catch (error) {
        if (!isMounted || abortControllerRef.current?.signal.aborted) return;
        console.error('[ProfilePage] Error fetching content:', error);
      }
    };

    console.log('[ProfilePage] useEffect - fetchUserContent triggered for profile:', profile?.id);
    fetchContent();

    return () => {
      console.log('[ProfilePage] useEffect cleanup - cancelling fetch for profile:', profile?.id);
      isMounted = false;
      abortController.abort();
      abortControllerRef.current = null;
    };
  }, [profile?.id, fetchUserContent]);

  useEffect(() => {
    if (profile) {
      setUserProfile({
        ...profile,
        role: profile.professional_title || 'Artist',
        streams: stats?.streams || 0,
        gems: stats?.gems || 0,
      });
    }
  }, [profile, stats]);

  console.log('[ProfilePage] RENDER DECISION POINT - isInitialLoading:', isInitialLoading, 'currentError:', currentError, 'userProfile:', !!userProfile);

  if (isInitialLoading) {
    console.log('[ProfilePage] Returning PageLoading due to isInitialLoading');
    return <PageLoading />;
  }

  if (currentError) {
    console.log('[ProfilePage] Returning error component:', currentError);
    const isNotFound = currentError.includes('not found') || currentError.includes('User not found');
    return (
      <div className="flex items-center justify-center h-screen">
        <div className="text-center p-6 max-w-md">
          <h2 className="text-2xl font-bold mb-2">
            {isNotFound ? 'Profile Not Found' : 'Error Loading Profile'}
          </h2>
          <p className="text-muted-foreground mb-4">
            {isNotFound
              ? "The profile you are looking for does not exist."
              : "An unexpected error occurred while trying to load the profile. Please try again later."}
          </p>
        </div>
      </div>
    );
  }

  if (!userProfile) {
    console.log('[ProfilePage] Returning PageLoading due to !userProfile');
    return <PageLoading />;
  }

  console.log('[ProfilePage] Rendering main profile content for:', userProfile.username);

  try {
    return (
      <div key={username} className="flex flex-col min-h-0">
        <ProfileHeader
          user={authUser || { id: '' }}
          profile={userProfile}
          stats={stats || {
            user_id: userProfile.id,
            streams: userProfile.streams || 0,
            followers: 0,
            following: 0,
            gems: userProfile.gems || 0,
            tracks: projects.reduce((acc, p) => acc + (p.audio_tracks?.length || 0), 0),
            playlists: playlists.length,
            albums: albums.length,
          }}
          updateProfile={updateProfile}
          setUploadType={setUploadType}
          setShowCreateProjectDialog={setShowCreateProjectDialog}
          setShowCreateSoundpackDialog={setShowCreateSoundpackDialog}
        />
        <ProfileInfo profile={userProfile} isLoading={loading} />
        <UploadDialog
          open={uploadType !== null}
          onOpenChange={handleUploadDialogClose}
          onUpload={handleUploadSuccess}
          type={uploadType || undefined}
        />
        <div className="container max-w-8xl mx-auto px-4 md:px-6 -mt-6 pb-12">
          <ProfileContent
            user={userProfile}
            stats={stats || {
              user_id: userProfile.id,
              streams: userProfile.streams || 0,
              followers: 0,
              following: 0,
              gems: userProfile.gems || 0,
              tracks: projects.reduce((acc, p) => acc + (p.audio_tracks?.length || 0), 0),
              playlists: playlists.length,
              albums: albums.length,
          }}
            projects={projects}
            playlists={playlists}
            albums={albums}
            showCreateProjectDialog={setShowCreateProjectDialog}
            setShowCreateProjectDialog={setShowCreateProjectDialog}
            showCreateSoundpackDialog={setShowCreateSoundpackDialog}
            setShowCreateSoundpackDialog={setShowCreateSoundpackDialog}
            onProjectCreated={fetchUserContent}
          />
        </div>
      </div>
    );
  } catch (renderError) {
    console.error('[ProfilePage] RENDER ERROR:', renderError);
    const isNotFound = currentError?.includes('not found') || currentError?.includes('User not found');
    return (
      <div className="flex items-center justify-center h-screen">
        <div className="text-center p-6 max-w-md">
          <h2 className="text-2xl font-bold mb-2">
            {isNotFound ? 'Profile Not Found' : 'Error Loading Profile'}
          </h2>
          <p className="text-muted-foreground mb-4">
            {isNotFound
              ? "The profile you are looking for does not exist."
              : "An unexpected error occurred while trying to load the profile. Please try again later."}
          </p>
        </div>
      </div>
    );
  }
}
